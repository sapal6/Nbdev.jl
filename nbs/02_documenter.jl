### A Pluto.jl notebook ###
# v0.11.13

using Markdown
using InteractiveUtils

# ‚ïî‚ïê‚ï° d4e575ae-28c8-11eb-236e-5f81e81ff094
#export
using Markdown

# ‚ïî‚ïê‚ï° 085e8560-17af-11eb-37c6-2bfceac4cf79
#export
using ReusePatterns

# ‚ïî‚ïê‚ï° 2a9f0c2e-07ba-11eb-2a22-cf9244b79ecd
#export
using Images, FileIO

# ‚ïî‚ïê‚ï° dbc2c790-08aa-11eb-12bb-579de4923c76
#export
using Publish

# ‚ïî‚ïê‚ï° b068dfd2-0eb3-11eb-109a-d1b6ef1eeca0
#export
begin
include("../src/Export.jl")
#const Nb = Export.Nb 
end

# ‚ïî‚ïê‚ï° 23c57f60-0eb4-11eb-20c0-7dac22387fc1
#export
include("../src/ConfigReader.jl")

# ‚ïî‚ïê‚ï° 27ff1d70-1201-11eb-2003-27cb52571be6
#export
include("../src/CodeRunner.jl")

# ‚ïî‚ïê‚ï° b495a5c0-0701-11eb-22a0-2f1a44fb9a15
md"what we need?

üëâ An automatic way to generate documents for code from docstrings.

üëâ If docstrings are not there then document should be genrated by show_doc or  something similar. For example you may not want to put docstrings inside a struct. In this case you have to use this customised function to document the struct.

üëâ Automatically create project readme from a common source."

# ‚ïî‚ïê‚ï° 1d83078e-2024-11eb-0e5f-51310d134662
#export
import Pluto: Notebook, Cell

# ‚ïî‚ïê‚ï° 4d29da30-1879-11eb-00ec-6de36df25d88
#export
load_nb=Export.load_nb

# ‚ïî‚ïê‚ï° a1a09fd0-193d-11eb-0a91-11a6df8cb651
#hide
ConfigReader.read_conf("../settings.ini")["lib_path"]

# ‚ïî‚ïê‚ï° 5a2e9790-201f-11eb-0df4-f90b3cc54f20
#export
begin
Base.@kwdef mutable struct Section
	line::String=""
end
	
Section(line)=Section(line=line)
end

# ‚ïî‚ïê‚ï° 28a4e100-17ac-11eb-172c-2d0e73460caa
#export
begin
struct Page
	sections::Array{Section,1}
    name::AbstractString
end
	
Page(sections, path)=Page(sections=sections, path=path)
end

# ‚ïî‚ïê‚ï° 2006e310-17af-11eb-2a88-27a4b31f1a00
md"now the save_nb can take the type Journal"

# ‚ïî‚ïê‚ï° 8a544780-0968-11eb-3104-f329ae48af16
md"`func img(img_path::String)`

     >Helper function to load image inside markdown

The img function loads image from a path."

# ‚ïî‚ïê‚ï° 4c59d7fe-07ba-11eb-2817-3919d9fc485f
#export
function img(img_path::String)
	load(img_path)
end

# ‚ïî‚ïê‚ï° a79f4e70-08aa-11eb-062c-5df3f8fe7da9
md"We will use Publish.jl to build our documentation which will also double up as a website for the project.

For this we will make a call to the `newsite()` function which will generate the basic folder structure for us."

# ‚ïî‚ïê‚ï° 8d851420-08af-11eb-26b0-63501c72011a
#hide
#cd("../nbs")

# ‚ïî‚ïê‚ï° 9478dd20-08af-11eb-1663-a7db573d2187
#hide
pwd()

# ‚ïî‚ïê‚ï° ecc6f510-0969-11eb-2f5e-0d2e1fd67981
md"""`func newsitegen(configpath::String="../settings.ini")`
	  > generate a new site directory. Takes the seetings.ini file from the project root by default"""

# ‚ïî‚ïê‚ï° e49c1970-08aa-11eb-094a-655c0f0c22af
#export
function newsitegen(configpath::String="../settings.ini")
	config=read_conf(configpath)
	if isdir("../docs")
		error("$(config["lib_name"])_docs directory is already present")
	else
	    #setup("../$(config["lib_name"])_docs")
		setup("../")
		mkdir("../docs")
	end
end

# ‚ïî‚ïê‚ï° e7a9d932-08ab-11eb-1f38-479b95b55ee6
#hide
#newsitegen()

# ‚ïî‚ïê‚ï° 5a2371e0-0953-11eb-3144-e3d76a772ed3
md"let's collect the markdown cells.

This can be done with the `collect_codecells` function in core.jl"

# ‚ïî‚ïê‚ï° 74879c7e-0eeb-11eb-31bf-251621d154a6

function test(x)
	x+1
end


# ‚ïî‚ïê‚ï° e2952860-1ade-11eb-20ca-091a45fab2f2
test(1)

# ‚ïî‚ïê‚ï° 2fc24ff0-11f7-11eb-18a8-1b2b989fa189
#hide
testNb=load_nb("02_documenter.jl", "md")

# ‚ïî‚ïê‚ï° 743238d0-1918-11eb-3dfc-6f30db92923c
md"`run_and_update` runs all md and example code and updates the notebook type wit output"

# ‚ïî‚ïê‚ï° 8691e572-1918-11eb-011c-639d3617e076
#export
function run_and_update_nb(file::AbstractString)
	notebook=load_nb(file, "md")
	return CodeRunner.execute_code(notebook)
end

# ‚ïî‚ïê‚ï° 5001a5b0-11ff-11eb-054a-6921da78afa3
md"As seen above we have a collection of markdown cells and cells which are neither intended to be exported or hidden. Such code cells are ones which we intend to have as examples in the document.

In such cases the normal code cells(cells without *#export*, *#hide* or *md* are supposed to be wrapped in triple backticks, that code getting executed, the output again wrapped in triple backticks and then inserted into the document.

The code to be executed(wrapped in backticks) and the ouput of such code(wrapped in backticks)."

# ‚ïî‚ïê‚ï° 592f96d0-1f5e-11eb-30b2-b9ca738d8c2a
md"how can we wrapthe code string to this ?"

# ‚ïî‚ïê‚ï° f1d7ed22-1f8a-11eb-035d-6de2cb48bb8b
Markdown.html(md"```func test end```")

# ‚ïî‚ïê‚ï° 6b9cb0f0-1f5e-11eb-1e15-9f0c8295b59f
code=testNb.cells[13].code

# ‚ïî‚ïê‚ï° c3d2cf20-1f8b-11eb-0381-01270b1494b3
cleanedCode=Export.strip(Export.strip(code,"\n"), "\n")

# ‚ïî‚ïê‚ï° a6012ef0-1f8c-11eb-3b2e-9d5c3ecdbc29
md"we can builda blocked code this way"

# ‚ïî‚ïê‚ï° 1d71bb00-1f8b-11eb-31de-69aebd625201
string("<p><code>",cleanedCode,"</code></p>\n")

# ‚ïî‚ïê‚ï° bda9c5a0-1f8a-11eb-396b-97f97add91db
md"How to stich only the code and the code output into a code block?

One way would be to read the executed notebook and look for cells wihtout code as **md** and then stich them together along with their output(at the end of each code block) into an html code block. This would be one line in section type.

In case the code.erroed is tru cancel the build and display a message."

# ‚ïî‚ïê‚ï° d75486f0-2022-11eb-2d95-aded3418c079
#export
begin
function stitchCode(cell::Cell)
	#cleanedCode=Export.strip(Export.strip(cell.code,"\n"), "\n")
	#string("<p><code>",cleanedCode,cell.output_repr,"</code></p>\n")
	string("```","\n$(cell.code)\n","\n$(cell.output_repr)\n","```\n")
end

function stitchCode(cellop::AbstractString)
	#cleanedop=Export.strip(Export.strip(cellop,"\n"), "\n")
	#string("<p><code>",cleanedop,"</code></p>\n")
	string("```","\n$cellop\n","```\n")
end
end

# ‚ïî‚ïê‚ï° 2cb1c480-2593-11eb-3936-75a74fa39fc1
#hide
d=methods(stitchCode, [Cell])

# ‚ïî‚ïê‚ï° 6c5b7850-2599-11eb-0cc9-39065ff9d40c
#hide
dstr=string(d.ms[1])

# ‚ïî‚ïê‚ï° 5728c070-2597-11eb-00cc-77de9dd2688b
#hide
m=match(r"[a-zA-Z]+\([^\)]*\)(\.[^\)]*\))?", dstr)

# ‚ïî‚ïê‚ï° f8d36f40-25d5-11eb-3332-fdb7cf134a0b
#hide
m.match

# ‚ïî‚ïê‚ï° 00989200-25d6-11eb-3139-8dd2ca0346f8
#export
grabFuncSig=(pat, fdesc) -> match(pat, fdesc).match

# ‚ïî‚ïê‚ï° 363dc920-25d6-11eb-37d7-b5ade368658f
#export
begin
pat4func=r"[a-zA-Z]+\([^\)]*\)(\.[^\)]*\))?"
pat4anonymfunc = r"\([^\)]*\)(\.[^\)]*\))?"
end

# ‚ïî‚ïê‚ï° 57f44f30-25d6-11eb-33dc-874e5a713bc5
grabFuncSig(pat4func,dstr)

# ‚ïî‚ïê‚ï° 9bf47390-25d6-11eb-1c3a-1d305aeb1c06
fstr = string(methods(grabFuncSig).ms[1])

# ‚ïî‚ïê‚ï° 81205160-25d6-11eb-1b59-dba990a416a7
grabFuncSig(pat4anonymfunc,fstr)

# ‚ïî‚ïê‚ï° 79109ba2-25d7-11eb-3a02-9de895379cae
#export
function showdDoc(fname, args...)
	fdesc=string(methods(fname).ms[1])
	fsig=grabFuncSig(pat4func, fdesc)
	if fsig==nothing
		return grabFuncSig(pat4anonymfunc, fdesc)
	else
		return fsig
	end
end

# ‚ïî‚ïê‚ï° 36b846d0-2024-11eb-3784-89a02343cd0b
#export
function createPage(filename::AbstractString, notebook::Notebook)
	sections=Section[]
	
	for cell in notebook.cells
		
		if cell.errored
			error("Build stopped. Seems like the code $cell.code has an error")
			break
	    end
		
	    if startswith(cell.code, "md")
			push!(sections, Section(cell.output_repr))
		elseif !startswith(cell.code, "#export") && !startswith(cell.code, "#hide")
			if occursin(cell.code, "showDoc")
				stitched_code=stitchCode(cell.output_repr)
				push!(sections, Section(stitched_code))
			else
				stitched_code=stitchCode(cell)
			    push!(sections, Section(stitched_code))
			end
		end
	end
	
	Page(sections, filename)
end

# ‚ïî‚ïê‚ï° 8d7b5280-28a0-11eb-282d-2dbf124460da
#export
begin
const _header = "<html>"
const _footer = "</html>"
end

# ‚ïî‚ïê‚ï° 60f5f6b0-28a1-11eb-1b18-27bdfed23c8c
#export
md2html(md)=Markdown.html(md)

# ‚ïî‚ïê‚ï° cec980d0-28a1-11eb-3089-ff1cbc3ee2db
#hide
str=uppercasefirst(Export.strip(Export.strip("02_documenter.jl", r"[0-9_]"), r".jl"))

# ‚ïî‚ïê‚ï° 311fd750-28a4-11eb-0d43-d3316d43e977
#hide
md=md"# $str"

# ‚ïî‚ïê‚ï° 41705300-28a4-11eb-1117-3b1c0d7b7ac9
#hide
md2html(md)

# ‚ïî‚ïê‚ï° 4c5c7c22-28a0-11eb-0069-cb78e0e7e0ee
#export
begin
	
function save_page(io, page)
    #println(io, _header)
    println(io, "")
		
	pageHeading=uppercasefirst(Export.strip(Export.strip(page.name, r"[0-9_]"), r".jl"))
	heading2md=md"# $pageHeading"
		
    println(io, md2html(heading2md))
		
	for section in page.sections
			println(io, section.line*"\n")
    end
		
	#print(io, _footer)	
end

function save_page(page::Page, path::String)
	file_name=uppercasefirst(Export.strip(Export.strip(page.name, r"[0-9_]"), r".jl"))
	open(joinpath(path, file_name*".md"), "w") do io
        save_page(io, page)
    end
end
end

# ‚ïî‚ïê‚ï° f31331e0-28c2-11eb-1014-95ed88d77469
#export
begin
function export2html(file::String, path::String)
	notebook=run_and_update_nb(joinpath("../nbs",file))
	page=createPage(file, notebook)
	save_page(page, path)
end
	
export2html(files::AbstractVector, path::String)=map(file->export2html(file, path), files)
	
export2html()=export2html(Export.readfilenames(), "../docs")
end

# ‚ïî‚ïê‚ï° 58b6fa50-0ba8-11eb-1ccf-1328cbe524b4
#hide
Export.notebook2script()

# ‚ïî‚ïê‚ï° Cell order:
# ‚ïü‚îÄb495a5c0-0701-11eb-22a0-2f1a44fb9a15
# ‚ï†‚ïêd4e575ae-28c8-11eb-236e-5f81e81ff094
# ‚ï†‚ïê085e8560-17af-11eb-37c6-2bfceac4cf79
# ‚ï†‚ïê2a9f0c2e-07ba-11eb-2a22-cf9244b79ecd
# ‚ï†‚ïêb068dfd2-0eb3-11eb-109a-d1b6ef1eeca0
# ‚ï†‚ïê1d83078e-2024-11eb-0e5f-51310d134662
# ‚ï†‚ïê4d29da30-1879-11eb-00ec-6de36df25d88
# ‚ï†‚ïê23c57f60-0eb4-11eb-20c0-7dac22387fc1
# ‚ï†‚ïêa1a09fd0-193d-11eb-0a91-11a6df8cb651
# ‚ï†‚ïê27ff1d70-1201-11eb-2003-27cb52571be6
# ‚ï†‚ïê5a2e9790-201f-11eb-0df4-f90b3cc54f20
# ‚ï†‚ïê28a4e100-17ac-11eb-172c-2d0e73460caa
# ‚ïü‚îÄ2006e310-17af-11eb-2a88-27a4b31f1a00
# ‚ïü‚îÄ8a544780-0968-11eb-3104-f329ae48af16
# ‚ï†‚ïê4c59d7fe-07ba-11eb-2817-3919d9fc485f
# ‚ïü‚îÄa79f4e70-08aa-11eb-062c-5df3f8fe7da9
# ‚ï†‚ïê8d851420-08af-11eb-26b0-63501c72011a
# ‚ï†‚ïê9478dd20-08af-11eb-1663-a7db573d2187
# ‚ï†‚ïêdbc2c790-08aa-11eb-12bb-579de4923c76
# ‚ïü‚îÄecc6f510-0969-11eb-2f5e-0d2e1fd67981
# ‚ï†‚ïêe49c1970-08aa-11eb-094a-655c0f0c22af
# ‚ï†‚ïêe7a9d932-08ab-11eb-1f38-479b95b55ee6
# ‚ïü‚îÄ5a2371e0-0953-11eb-3144-e3d76a772ed3
# ‚ï†‚ïê74879c7e-0eeb-11eb-31bf-251621d154a6
# ‚ï†‚ïêe2952860-1ade-11eb-20ca-091a45fab2f2
# ‚ï†‚ïê2fc24ff0-11f7-11eb-18a8-1b2b989fa189
# ‚ïü‚îÄ743238d0-1918-11eb-3dfc-6f30db92923c
# ‚ï†‚ïê8691e572-1918-11eb-011c-639d3617e076
# ‚ïü‚îÄ5001a5b0-11ff-11eb-054a-6921da78afa3
# ‚ïü‚îÄ592f96d0-1f5e-11eb-30b2-b9ca738d8c2a
# ‚ï†‚ïêf1d7ed22-1f8a-11eb-035d-6de2cb48bb8b
# ‚ï†‚ïê6b9cb0f0-1f5e-11eb-1e15-9f0c8295b59f
# ‚ï†‚ïêc3d2cf20-1f8b-11eb-0381-01270b1494b3
# ‚ï†‚ïêa6012ef0-1f8c-11eb-3b2e-9d5c3ecdbc29
# ‚ï†‚ïê1d71bb00-1f8b-11eb-31de-69aebd625201
# ‚ïü‚îÄbda9c5a0-1f8a-11eb-396b-97f97add91db
# ‚ï†‚ïêd75486f0-2022-11eb-2d95-aded3418c079
# ‚ï†‚ïê2cb1c480-2593-11eb-3936-75a74fa39fc1
# ‚ï†‚ïê6c5b7850-2599-11eb-0cc9-39065ff9d40c
# ‚ï†‚ïê5728c070-2597-11eb-00cc-77de9dd2688b
# ‚ï†‚ïêf8d36f40-25d5-11eb-3332-fdb7cf134a0b
# ‚ï†‚ïê00989200-25d6-11eb-3139-8dd2ca0346f8
# ‚ï†‚ïê363dc920-25d6-11eb-37d7-b5ade368658f
# ‚ï†‚ïê57f44f30-25d6-11eb-33dc-874e5a713bc5
# ‚ï†‚ïê9bf47390-25d6-11eb-1c3a-1d305aeb1c06
# ‚ï†‚ïê81205160-25d6-11eb-1b59-dba990a416a7
# ‚ï†‚ïê79109ba2-25d7-11eb-3a02-9de895379cae
# ‚ï†‚ïê36b846d0-2024-11eb-3784-89a02343cd0b
# ‚ï†‚ïê8d7b5280-28a0-11eb-282d-2dbf124460da
# ‚ï†‚ïê60f5f6b0-28a1-11eb-1b18-27bdfed23c8c
# ‚ï†‚ïêcec980d0-28a1-11eb-3089-ff1cbc3ee2db
# ‚ï†‚ïê311fd750-28a4-11eb-0d43-d3316d43e977
# ‚ï†‚ïê41705300-28a4-11eb-1117-3b1c0d7b7ac9
# ‚ï†‚ïê4c5c7c22-28a0-11eb-0069-cb78e0e7e0ee
# ‚ï†‚ïêf31331e0-28c2-11eb-1014-95ed88d77469
# ‚ï†‚ïê58b6fa50-0ba8-11eb-1ccf-1328cbe524b4
