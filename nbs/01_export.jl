### A Pluto.jl notebook ###
# v0.11.13

using Markdown
using InteractiveUtils

# ╔═╡ 74a36b30-1478-11eb-2747-454b32cbbcfa
#export
using ReusePatterns

# ╔═╡ 0aecd4c0-0e14-11eb-1619-4f5e0ced1279
#export
import Pluto: Notebook, Cell, load_notebook

# ╔═╡ 5babb7fe-0e13-11eb-27e1-df7f70862c78
md"let's write the reult to a output file.

* Do notebook2script in any cell to take all the notebooks in the nbs folder and convert those to script.

* The output file should be same as the input file.
* The root directory should be same as the root of the input notebook.
* The directory should be root/src if it's a source code
* The directory should be root/test if it's a test code.
* The directory should be root/docs if it's mark down."

# ╔═╡ d2a442c0-0eb2-11eb-1ea8-d507d9145823
#export
function processMdChunk(mdChunk::String)
	chopMdMarker(mdChunk)
end

# ╔═╡ 6ff1ad80-1479-11eb-3868-0df000f47cc9
md"create a new struct which would extend the Notebook type. This would store the executed cell if any.

for example executed markdown and the executed code output(if any) else this new field will have nothing.

This new notebook type will give a blueprint which can then be used to write contents to a files."

# ╔═╡ a5bfff40-1620-11eb-2824-2d49985a022d
#export
begin
Base.@kwdef mutable struct Nucleus
	code::String=""
	parsedcode::Union{Nothing,Expr}=nothing
	end
	
code(cell::Cell) = cell.code
parsedcode(cell::Cell) = cell.parsedcode

Nucleus(code, parsedcode) = Nucleus(code = code, parsedcode = parsedcode)
end

# ╔═╡ b686b890-1671-11eb-2303-15bbe39815a4
md"some examples or tests"

# ╔═╡ 4de7f772-1673-11eb-161b-9f0b0db7826a
nb= load_notebook("01_export.jl")

# ╔═╡ 75368710-1673-11eb-38f7-0b1dcee4d9db
mycode=code(nb.cells[1])

# ╔═╡ c44e0670-1673-11eb-3d43-67fbdb22dc85
Nucleus(code=mycode)

# ╔═╡ d17ebf90-1486-11eb-0d41-b967a8ab82ba
#export
begin
mutable struct Nb
	nuclei::Array{Nucleus,1}
	name::AbstractString
end

nuclei(nuclei::Array) = nuclei
name(name::AbstractString) = name
end

# ╔═╡ ff27d270-1557-11eb-015e-e551820b5d08
md"This can later be used for struct inheritence"

# ╔═╡ 984a07b0-0eb5-11eb-14e8-7be4b6d05010
md"`collect_codecells` will dispatch on two things
1. If it's *#export* then parse the code as string adn give it back.
2. If it's *md* or nothing then parse the code as string and then pass it onto a different function.
   1. This new function shall execute the markdown and push it to string then it keeps on appending the same till it encounters a cell with no marker.
    2. At this point things start to get interesting. 
    3. Any cell which doesn't start with *#export*, *#hide*, *md* should be considered as examples.
    4. Such cells should be contaenated together into a single string and then executed and the output concatenated into the same string as earlier markdown.
    5. The actual code of such cells should be wrapped in backticks.

> One thing to note is that whenever there is an error, the doc build stops"

# ╔═╡ ee16fab0-155c-11eb-217a-a1ffcea885bc
md"the Nb type is the definitve type of notebook here. this can then be extended to create code only notebooks or document only notebooks."

# ╔═╡ 1941c9ce-1770-11eb-1371-e775bcb1d68a
md"Headers for the exported script file"

# ╔═╡ 296282f0-1770-11eb-0900-b37a94fbc69c
#export
begin
const _header = "### A Nbdev script file ###"
const _sub_header = "### Autogenerated file. Don't modify. ###"
end

# ╔═╡ d4daaac0-0eb2-11eb-1d4d-7763fcfc0ed2
#export
begin
function collect_nuclei(notebook::Notebook, marker::String)
	notebook_cells=notebook.cells
	nuclei=[]
		
	if marker=="md"
		nuclei=collect_nuclei(notebook::Notebook, notebook_cells)
	else
	    for i in 1:length(notebook_cells)
	    	raw_code=code(notebook_cells[i])
	    	parsed_code=parsedcode(notebook_cells[i])
	    	nucleus=Nucleus(raw_code, parsed_code)
	    	
	    	if startswith(raw_code, marker)
	            push!(nuclei,nucleus)
            end
	    	
	    end
	end
	 nuclei
	
end
	
#TODO: if raw code i snot  export or hide
#collect those Cells and make an array
function collect_nuclei(notebook::Notebook, notebook_cells)
	cells=Cell[]
    for i in 1:length(notebook_cells)
		raw_code=code(notebook_cells[i])
		
		if !startswith(raw_code, "#hide") && !startswith(raw_code, "#export") 
	        push!(cells,Cell(raw_code))
        end
		
	end
	cells
end
end

# ╔═╡ 5ec8f7a2-1755-11eb-3b49-ad9dd182803a
#export
begin
	
load_nb(filename::String, marker::String) = _load_notebook(filename, marker)
	
function _load_notebook(filename::String, marker::String)
		notebook=load_notebook(filename)
		collected_nuclei=nuclei(collect_nuclei(notebook, marker))
		
		if marker=="md"
			Notebook(collected_nuclei)
		else
			Nb(collected_nuclei, filename)
		end
end

end

# ╔═╡ c9545440-1758-11eb-2e11-bd3a77035c43
md"Let's see an example"

# ╔═╡ d13f9ca0-1758-11eb-143b-29bccf950cae
testnb= load_nb("01_export.jl", "#export")

# ╔═╡ 2fc44d62-1dcc-11eb-2d96-775a29784c9a
testnbs= load_nb("01_export.jl", "md")

# ╔═╡ e229a820-1777-11eb-37c5-c108ab5f7110
testnb.nuclei[1].code

# ╔═╡ 54f54160-176f-11eb-0317-3542cb72f89f
md"something to save files"

# ╔═╡ 35a01900-1771-11eb-01a7-39297caf95fd
k="01_export.jl"

# ╔═╡ 4c511e5e-1771-11eb-3c8e-5785e7399d70
#export
strip=(x,y) -> replace(x, y=>"")

# ╔═╡ 7b999f90-1775-11eb-031e-69d461ec4150
"module $(uppercasefirst(strip(strip(k, r"[0-9_]"), r".jl")))"

# ╔═╡ 76f97bd0-177b-11eb-2d78-77c72b2aef81
md"To export the required code, the following scenarios must be considered.

👉 Check if the file is in the src directory. If it's there then overwrite it. 


👉 If it's not there then create and then write."

# ╔═╡ 6069d790-176f-11eb-3020-41b450d430ad
#export
begin
	
function save_nb(io, notebook)
    println(io, _header)
    println(io, _sub_header)
    println(io, "")
    println(io, "module $(uppercasefirst(strip(strip(notebook.name, r"[0-9_]"), r".jl")))")
	for nucleus in notebook.nuclei
			println(io, nucleus.code*"\n")
    end
	#notebook
	print(io, "end")	
end

function save_nb(notebook::Nb, path::String)
	file_name=uppercasefirst(strip(notebook.name, r"[0-9_]"))
	open(joinpath(path, file_name), "w") do io
        save_nb(io, notebook)
    end
end
end

# ╔═╡ cdd23fa0-1776-11eb-2343-a570b848c87e
save_nb(testnb, "../testpath")

# ╔═╡ b9a15e60-0e13-11eb-199d-f50a49f5bc44
md"we will read files in the curren tpath whihc should be the /nbs folder in your project. Thie will host all your notebooks"

# ╔═╡ e46146c0-0eb2-11eb-0c7f-df5be4faaf93
function show_output(file_path::String, file::String)
	if isfile(file_path)
		@show "$file exported"
	end
end

# ╔═╡ 0be54350-177c-11eb-285a-93dd4d45e40e
#export
function export_file(file::String, path::String, marker::String)
	notebook=load_nb(file, "#export")
	save_nb(notebook, path)
end

# ╔═╡ 41d65310-0e11-11eb-1a36-87dc9ac941fa
#export
function export_content(files::AbstractVector, path::String, marker::String)
	map(file->export_file(file, path, marker), files)
end

# ╔═╡ 01608690-0e14-11eb-3faa-9b960f57f3fe
#export
function getfile_extension(filename)
    return filename[findlast(isequal('.'),filename):end]
end

# ╔═╡ cdada98e-0e13-11eb-30aa-1777efffb181
#export
begin
function readfilenames()
	files=[]
	for file in readdir()
			if getfile_extension(file)== ".jl"
				push!(files,file)
			end
	end
	files
end

function readfilenames(dir::String)
	files=cd(readdir, dir)
	files
end
end

# ╔═╡ 9b436180-177c-11eb-1c9a-ffbac62c95df
readfilenames()

# ╔═╡ 06649ce0-177d-11eb-2092-d7160725252a
 getfile_extension("test.jl")

# ╔═╡ b34f9d82-0ede-11eb-0f08-afa0cc898e80
#export
#TODO: Too many loops. Need to clear this either 
#by broadcasting or something more efficient
#TODO: User should eb able to get messages about which
#files are updated
#TODO: currently output inside loop is not shown in pluto notebooks.
#so, the show_output displays all stuffs in the console.
#maybe a progress bar would be better
function notebook2script()
	export_content(readfilenames(), "../src", "#export")
end

# ╔═╡ baf3f1d0-0ede-11eb-2c02-1f53ed1a6cd7
notebook2script()

# ╔═╡ Cell order:
# ╠═74a36b30-1478-11eb-2747-454b32cbbcfa
# ╠═0aecd4c0-0e14-11eb-1619-4f5e0ced1279
# ╟─5babb7fe-0e13-11eb-27e1-df7f70862c78
# ╠═d2a442c0-0eb2-11eb-1ea8-d507d9145823
# ╟─6ff1ad80-1479-11eb-3868-0df000f47cc9
# ╠═a5bfff40-1620-11eb-2824-2d49985a022d
# ╠═b686b890-1671-11eb-2303-15bbe39815a4
# ╠═4de7f772-1673-11eb-161b-9f0b0db7826a
# ╠═75368710-1673-11eb-38f7-0b1dcee4d9db
# ╠═c44e0670-1673-11eb-3d43-67fbdb22dc85
# ╠═d17ebf90-1486-11eb-0d41-b967a8ab82ba
# ╟─ff27d270-1557-11eb-015e-e551820b5d08
# ╟─984a07b0-0eb5-11eb-14e8-7be4b6d05010
# ╟─ee16fab0-155c-11eb-217a-a1ffcea885bc
# ╟─1941c9ce-1770-11eb-1371-e775bcb1d68a
# ╠═296282f0-1770-11eb-0900-b37a94fbc69c
# ╠═d4daaac0-0eb2-11eb-1d4d-7763fcfc0ed2
# ╠═5ec8f7a2-1755-11eb-3b49-ad9dd182803a
# ╟─c9545440-1758-11eb-2e11-bd3a77035c43
# ╠═d13f9ca0-1758-11eb-143b-29bccf950cae
# ╠═2fc44d62-1dcc-11eb-2d96-775a29784c9a
# ╠═e229a820-1777-11eb-37c5-c108ab5f7110
# ╟─54f54160-176f-11eb-0317-3542cb72f89f
# ╠═35a01900-1771-11eb-01a7-39297caf95fd
# ╠═4c511e5e-1771-11eb-3c8e-5785e7399d70
# ╠═7b999f90-1775-11eb-031e-69d461ec4150
# ╟─76f97bd0-177b-11eb-2d78-77c72b2aef81
# ╠═6069d790-176f-11eb-3020-41b450d430ad
# ╠═cdd23fa0-1776-11eb-2343-a570b848c87e
# ╟─b9a15e60-0e13-11eb-199d-f50a49f5bc44
# ╠═cdada98e-0e13-11eb-30aa-1777efffb181
# ╠═9b436180-177c-11eb-1c9a-ffbac62c95df
# ╠═e46146c0-0eb2-11eb-0c7f-df5be4faaf93
# ╠═0be54350-177c-11eb-285a-93dd4d45e40e
# ╠═41d65310-0e11-11eb-1a36-87dc9ac941fa
# ╠═01608690-0e14-11eb-3faa-9b960f57f3fe
# ╠═06649ce0-177d-11eb-2092-d7160725252a
# ╠═b34f9d82-0ede-11eb-0f08-afa0cc898e80
# ╠═baf3f1d0-0ede-11eb-2c02-1f53ed1a6cd7
