{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"CodeRunner/","text":"CodeRunner You need to have something to capture the output. This is useful when you want to have examples or capture test output in the docs. I think the simplest way to do this is to do the following\ud83d\udc47 Take a notebook. Create a fake server, fake client etc. Run the notebook cell by cell and update the notebook with the output. This is taken straight from Pluto's webserver code execute_code execute_code(notebook::Notebook)\u2013> This function does the following Take a notebook. Create a fake server, fake client etc. Run the notebook cell by cell and update the notebook with the output.","title":"CodeRunner"},{"location":"Documenter/","text":"Documenter Lower Level Entities(Structs, methods etc.) These are the objects on which nbdev's Documenter module was built. You can use it to extend nbdev but these are automtically used by Nbdev's internal engine to generate code files for you. Section type struct Section\u2013> This is like the section of a page and is made up of one or multiple lines. Fields: line\u2013> String which makes up a section Section(line)\u2013> Helper function to call the constructor of the type Section line(section::Section)\u2013> Getter for accessing the underlying field line. Example begin section=Section(\"This is a test line\") line(section) end ------ Output ------ \"This is a test line\" Page Type Page\u2013> The type that represents a page in a document. Fields: sections\u2013> Array of Section type. name\u2013> Name of the module being documented. Page\u2013> Helper function to create constructer for Page type. sections\u2013> Getter for accessing the underlying field sections of Page. name\u2013> Getter for accessing the underlying field name of Page. A \ud83d\udcc3 is made up of several sections. These sections can be example codes, text ,graphs(to be implemented) and function documentation and several pages. The Page type helps in implementing this concept into code. Example begin page=Page([Section(\"iny, meeny, miny mo\"), Section(\"\ud83d\ude48 \ud83d\ude4a \ud83d\ude49\")], \"Monkey module\") sections(page) end ------ Output ------ Any[\"Main.workspace4.Section\", Tuple{Int64, Any}[(1, (Dict{Symbol, Any}(:prefix => \"Section\", :elements => Any[(:line, (\"\\\"iny, meeny, miny mo\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Section\", :objectid => \"feebbea666a8e4ee\"), MIME type application/vnd.pluto.tree+object)), (2, (Dict{Symbol, Any}(:prefix => \"Section\", :elements => Any[(:line, (\"\\\"\ud83d\ude48 \ud83d\ude4a \ud83d\ude49\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Section\", :objectid => \"829704086dff6e2c\"), MIME type application/vnd.pluto.tree+object))], :Array, \"\", \"2ae47e853db14b27\"] page ------ Output ------ Any[\"Page\", Any[(:sections, (Dict{Symbol, Any}(:prefix => \"Main.workspace4.Section\", :elements => Tuple{Int64, Any}[(1, (Dict{Symbol, Any}(:prefix => \"Section\", :elements => Any[(:line, (\"\\\"iny, meeny, miny mo\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Section\", :objectid => \"feebbea666a8e4ee\"), MIME type application/vnd.pluto.tree+object)), (2, (Dict{Symbol, Any}(:prefix => \"Section\", :elements => Any[(:line, (\"\\\"\ud83d\ude48 \ud83d\ude4a \ud83d\ude49\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Section\", :objectid => \"829704086dff6e2c\"), MIME type application/vnd.pluto.tree+object))], :type => :Array, :prefix_short => \"\", :objectid => \"2ae47e853db14b27\"), MIME type application/vnd.pluto.tree+object)), (:name, (\"\\\"Monkey module\\\"\", MIME type text/plain))], :struct, \"Page\", \"8cb32a20a1fa86d3\"] typeof(page) ------ Output ------ Page run and update run_and_update_nb uses the load_notebook_nobackup function in Pluto.jl. There are multiple ways to achieve what this function achieves without depending on Pluto internals but for now this was the quickiest way to achieve this. Note- Depending on Pluto internal to run and update a notebook makes it difficult to run unit test for this function from within pluto itself because a Pluto cell is treated as worker 2, 3 and so on but when you do load_notebook() then it spins up another worker. Only worker 1 can spwan further processes and not a notebook cell. stitchCode stitchCode(cell::Cell)\u2013> Stitches the code in a Pluto notebook cell with the output of that code. The output is a code block. stitchCode(cellop::AbstractString)\u2013> Removes the quotes from a string and creates a code block with that string inside the newely formed code block stitchCode(fdocs::FunctionDocs)\u2013> When supplied with a FunctionDocs type, stitchCode appends together the object docstrings and generates documentation for that particular object FunctionDocs struct FunctionDocs\u2013> Stores the document of different objects. funcDocs\u2013> Array of strings. FunctionDocs(funcDocs)\u2013> Helper for accessing the FunctionDocs constructer. Example begin funcdocs=FunctionDocs([\"i\", \"j\"]) funcdocs.funcDocs end ------ Output ------ Any[\"String\", Tuple{Int64, Any}[(1, (\"\\\"i\\\"\", MIME type text/plain)), (2, (\"\\\"j\\\"\", MIME type text/plain))], :Array, \"\", \"504c835612561e68\"] collectFuncDocs collectFuncDocs(obj)\u2013> Collects objects (functions, methods, macro structs etc.) and creates an array of documents (generated from teh docstrings). Creates aFunctionDocs type from these documents. Example collectFuncDocs(stitchCode).funcDocs ------ Output ------ Any[\"String\", Tuple{Int64, Any}[(1, (\"\\\"> stitchCode(cell::Cell)\u2013> Stitches the code in a Pluto notebook cell with the output of that code. The output is a code block.\\\\n\\\\n\\\"\", MIME type text/plain)), (2, (\"\\\"> stitchCode(cellop::AbstractString)\u2013> Removes the quotes from a string and creates a code block with that string inside the newely formed code block\\\\n\\\\n\\\"\", MIME type text/plain)), (3, (\"\\\"> stitchCode(fdocs::FunctionDocs)\u2013> When supplied with a FunctionDocs type, stitchCode appends together the object docstrings and generates documentation for that particular object\\\\n\\\\n\\\"\", MIME type text/plain))], :Array, \"\", \"ef6e481a53739452\"] Higher Level API These higher level APIs can either be used directly or are already used internally by nbdev. One such functions which can be used directly is... showDoc showDoc(o)\u2013> Takes an object and builds markdown documentation. struct MyStruct name end ------ Output ------ mystruct=MyStruct(\"test\") ------ Output ------ Any[\"MyStruct\", Any[(:name, (\"\\\"test\\\"\", MIME type text/plain))], :struct, \"MyStruct\", \"eaf3dde155ac40a7\"] typeof(mystruct) ------ Output ------ MyStruct Currently nbdev is unable to recognize the docstrings of inline expressions.\ud83d\udc47 \"> inlinetest--> This is a inline test expression\" inlinetest=str->replace(str, \"1\"=> \"one\") ------ Output ------ Main.workspace4.inlinetest createPage CreatePage\u2013> Creates the Page type from the markdown and example code cells of the supplied notebook. The filename is the name of the notebook which is parsed. While generating document you don't need to call this function. This is done automatically\ud83d\ude03 for you when nbdev generates documents. md2html \"\"\" > md2html(md)--> Tiny helper to format a markdown into html. \"\"\" md2html(md)=Export.strip(Markdown.html(md), \"\\n\") ------ Output ------ Main.workspace4.md2html Sometimes it better to have tiny helpers like this. The md2html converts the supplied markdown into a visible html.\ud83c\udf88\ud83c\udf88 Example \" This is a test \" sw Checks if a given string startwith a certain susbstring. Helpful when there are a list of strings to match. Example save_page save_page(io, page::Page)\u2013> Take the contents from a Page type and write to the io save_page(page::Page, path::String)\u2013> Given a Page type and the required path, creates the related markdwon file in the specified path. The name of the resulting markdown file is same as the nameof the notebook for which the document is generated save_page(docnames::Array{String,1})\u2013> Given an array of documents, creates the related table of contents in \\toc.md\\ Nbdev calls the required method of save_page automatically during document generation. export2md export2md(file::String, path::String)\u2013> Generate document for a file in the given path export2md(files::AbstractVector, path::String)\u2013> Map the export2md(file, path) to a given vector of file. export2md()\u2013> Higher level API to generate documents for all the valid notebooks The export2md() is what gets summoned when document generation is invoked. Like most things in nbdev (and unlike most things in life) this too gets invoked automatically. \ud83e\udd73 #### export2readme ------ Output ------","title":"Documenter"},{"location":"Export/","text":"Export The Export module helps in exporting the code to script files. Lower Level Entities(Structs, methods etc.) These are the objects on which nbdev's Export module was built. You can use it to extend nbdev but these are automtically used by Nbdev's internal engine to generate code files for you. Nucleus type struct Nucleus\u2013> This is the lowest entity of a code notebook. This type represents the code cell in a Pluto notebook. Fields: code\u2013> String which makes up a code cell Nucleus(code)\u2013>Getter for accessing the constructer of the Nucleus type Every time a code cell is parsed, it gets stored as a Nucleus type. The stored code can then be accessed using the code field in the Nucleus type. Example sample_code=\"a=1+1\" ------ Output ------ \"a=1+1\" nucleus=Nucleus(sample_code) ------ Output ------ Any[\"Nucleus\", Any[(:code, (\"\\\"a=1+1\\\"\", MIME type text/plain))], :struct, \"Nucleus\", \"47548a9678eb6201\"] nucleus.code ------ Output ------ \"a=1+1\" Nb type struct Nb\u2013> a notebook having nuclei made up of code cells only. Fields: nuclei\u2013> Array of Nucleus type name\u2013> name of notebook nuclei(nuclei::Array)\u2013> Helper to collect an array of Nucleus. nuclei(nuclei::Array)\u2013> Helper to collect an name of a notebook. A Nb type is used to collect all code cells(which are contained in the Nucleus type. These code cells are actual code represented as string. Example samplecodes=[Nucleus(\"a=1+1\"), Nucleus(\"function test(x) x+1 end\"), Nucleus(\"test(2)\")] ------ Output ------ Any[\"Main.workspace2.Nucleus\", Tuple{Int64, Any}[(1, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"a=1+1\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"306d40c84759e9a7\"), MIME type application/vnd.pluto.tree+object)), (2, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"function test(x) x+1 end\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"c2976b556bae3e4f\"), MIME type application/vnd.pluto.tree+object)), (3, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"test(2)\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"6dde1c26c23ba23b\"), MIME type application/vnd.pluto.tree+object))], :Array, \"\", \"403f1afae8420fcc\"] nb=Nb(samplecodes, \"testnb.jl\") ------ Output ------ Any[\"Nb\", Any[(:nuclei, (Dict{Symbol, Any}(:prefix => \"Main.workspace2.Nucleus\", :elements => Tuple{Int64, Any}[(1, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"a=1+1\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"306d40c84759e9a7\"), MIME type application/vnd.pluto.tree+object)), (2, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"function test(x) x+1 end\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"c2976b556bae3e4f\"), MIME type application/vnd.pluto.tree+object)), (3, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"test(2)\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"6dde1c26c23ba23b\"), MIME type application/vnd.pluto.tree+object))], :type => :Array, :prefix_short => \"\", :objectid => \"403f1afae8420fcc\"), MIME type application/vnd.pluto.tree+object)), (:name, (\"\\\"testnb.jl\\\"\", MIME type text/plain))], :struct, \"Nb\", \"4be33ca50065e252\"] nb.nuclei ------ Output ------ Any[\"Main.workspace2.Nucleus\", Tuple{Int64, Any}[(1, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"a=1+1\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"306d40c84759e9a7\"), MIME type application/vnd.pluto.tree+object)), (2, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"function test(x) x+1 end\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"c2976b556bae3e4f\"), MIME type application/vnd.pluto.tree+object)), (3, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"test(2)\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"6dde1c26c23ba23b\"), MIME type application/vnd.pluto.tree+object))], :Array, \"\", \"403f1afae8420fcc\"] nb.name ------ Output ------ \"testnb.jl\" collect_nuclei(notebook::ScrubbedNotebook, marker)\u2013> Reads a notebook, collects code from code cells and returns an array of Nucelus. collect_nuclei(notebook::ScrubbedNotebook, marker) reads the entire notebook cell by cell and then checks if the content of that cell starts with a marker, only then it builds an array of the Nucleus type. load scrubbed nb load scrubbed nb(io, path)::ScrubbedNotebook\u2013> These are modification of the Pluto.load_notebook methods. Scrubs the notebook of all stuff but the code to be exported. load_scrubbed_nb reads the notebook in the given path cell by cell, while ignoring the stuffs in the notebook like the cell order delimeters and the cell start delimeter. The result is a ScrubbedNotebook type which contains only the code which you intend to export. High Level APIs This too are called automatically by Nbdev. load_nb load nb(filename::String, marker::String)\u2013> High level function which calls _load nb load nb(filename::String, marker::String)\u2013> creates a scrubbed notebook and returns a curated Nb type having code to be exported. ScrubbedNotebook testnb= load_nb(\"01_export.jl\", \"#export\") ------ Output ------ Any[\"Nb\", Any[(:nuclei, (Dict{Symbol, Any}(:prefix => \"Main.workspace2.Nucleus\", :elements => Tuple{Int64, Any}[(1, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nimport Pluto: Notebook, Cell, load_notebook_nobackup\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"ff74b8c09c2a01d\"), MIME type application/vnd.pluto.tree+object)), (2, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nfunction processMdChunk(mdChunk::String)\\\\n\\\\tchopMdMarker(mdChunk)\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"7234e7b14e3dd8b6\"), MIME type application/vnd.pluto.tree+object)), (3, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nbegin\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> struct Nucleus--> This is the lowest entity of a code notebook. This type represents the code cell in a Pluto notebook.\\\\n> * Fields:\\\\n> * code--> String which makes up a code cell\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nBase.@kwdef mutable struct Nucleus\\\\n\\\\tcode::String=\\\\\\\"\\\\\\\"\\\\n\\\\tend\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> Nucleus(code)-->Getter for accessing the constructer of the Nucleus type\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nNucleus(code) = Nucleus(code = code)\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"30d3cd894b7ba5ab\"), MIME type application/vnd.pluto.tree+object)), (4, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nbegin\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> struct Nb--> a notebook having nuclei made up of code cells only.\\\\n> * Fields:\\\\n> * nuclei--> Array of Nucleus type\\\\n> * name--> name of notebook\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nmutable struct Nb\\\\n\\\\tnuclei::Array{Nucleus,1}\\\\n\\\\tname::AbstractString\\\\nend\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> nuclei(nuclei::Array)--> Helper to collect an array of Nucleus.\\\\t\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nnuclei(nuclei::Array) = nuclei\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> nuclei(nuclei::Array)--> Helper to collect an name of a notebook.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nname(name::AbstractString) = name\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"4a9e22027f104b91\"), MIME type application/vnd.pluto.tree+object)), (5, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nbegin\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nHeaders that would appear in a code file\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nconst _header = \\\\\\\"### A Nbdev script file ###\\\\\\\"\\\\nconst _sub_header = \\\\\\\"### Autogenerated file. Don't modify. ###\\\\\\\"\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"16bbf13b174bcf5b\"), MIME type application/vnd.pluto.tree+object)), (6, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nThis had to be done because having the cell iddelimeter as a constant gives an error during parsing the notebook\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\ncell_id_delimiter=string(\\\\\\\"#\\\\\\\",\\\\\\\" \u2554\u2550\u2561 \\\\\\\")\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"c7f527202d292b1\"), MIME type application/vnd.pluto.tree+object)), (7, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nmarks the end of a cell\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nconst _cell_suffix = \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"a869a2ca3aa73257\"), MIME type application/vnd.pluto.tree+object)), (8, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> struct ScrubbedNotebook--> Represents a notebook from which all but code to be exported are scrubbed off.\\\\n> * Fields-->\\\\n> * cells--> Vector of strings.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nmutable struct ScrubbedNotebook\\\\n\\\\tcells::Array{String, 1}\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"fdb9e50ae547b3af\"), MIME type application/vnd.pluto.tree+object)), (9, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> collect_nuclei(notebook::ScrubbedNotebook, marker)--> Reads a notebook, collects code from code cells and returns an array of Nucelus.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction collect_nuclei(notebook::ScrubbedNotebook, marker)\\\\n\\\\tnotebook_cells=notebook.cells\\\\n\\\\tnuclei=[]\\\\n\\\\t\\\\t\\\\n for i in 1:length(notebook_cells)\\\\n \\\\traw_code=notebook_cells[i]\\\\n \\\\tnucleus=Nucleus(raw_code)\\\\n \\\\t\\\\n \\\\tif startswith(raw_code, marker)\\\\n push!(nuclei,nucleus)\\\\n end\\\\n \\\\t\\\\n end\\\\n\\\\t nuclei\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"7c865c0f964b693\"), MIME type application/vnd.pluto.tree+object)), (10, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nbegin\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n>load_scrubbed_nb(io, path)::ScrubbedNotebook--> These are modification of the Pluto.load_notebook methods. Scrubs the notebook of all stuff but the code to be exported.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction load_scrubbed_nb(io, path)::ScrubbedNotebook\\\\n collected_cells = []\\\\n\\\\t\\\\t\\\\n\\\\t# ignore first bits of file\\\\n readuntil(io,cell_id_delimiter)\\\\n\\\\n last_read = \\\\\\\"\\\\\\\"\\\\n while !eof(io)\\\\n cell_id_str = String(readline(io))\\\\n if cell_id_str == \\\\\\\"Cell order:\\\\\\\"\\\\n break\\\\n else\\\\n code_raw = String(readuntil(io, cell_id_delimiter))\\\\n # change Windows line endings to Linux\\\\n code_normalised = replace(code_raw, \\\\\\\"\\\\\\\\r\\\\\\\\n\\\\\\\" => \\\\\\\"\\\\\\\\n\\\\\\\")\\\\n # remove the cell appendix\\\\n code = code_normalised[1:prevind(code_normalised, end, length(_cell_suffix))]\\\\n\\\\n read_cell = code\\\\n push!(collected_cells, read_cell)\\\\n end\\\\n end\\\\n\\\\t\\\\t\\\\n\\\\tScrubbedNotebook(collected_cells)\\\\nend\\\\n\\\\t\\\\nfunction load_scrubbed_nb(path::String)::ScrubbedNotebook\\\\n local loaded\\\\n open(path, \\\\\\\"r\\\\\\\") do io\\\\n loaded = load_scrubbed_nb(io, path)\\\\n end\\\\n loaded\\\\nend\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"2d31ed14c437c5f2\"), MIME type application/vnd.pluto.tree+object)), (11, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nbegin\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> load_nb(filename::String, marker::String)--> High level function which calls _load_nb\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nload_nb(filename::String, marker::String) = _load_nb(filename, marker)\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> _load_nb(filename::String, marker::String)--> creates a scrubbed notebook and returns a curated Nb type having code to be exported.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction _load_nb(filename::String, marker::String)\\\\n\\\\t\\\\t#notebook=load_notebook_nobackup(filename)\\\\n\\\\t\\\\tscrubbedNotebook=load_scrubbed_nb(normpath(joinpath(@__FILE__,\\\\\\\"..\\\\\\\",\\\\\\\"..\\\\\\\", \\\\\\\"nbs\\\\\\\", filename)))\\\\n\\\\t\\\\tcollected_nuclei=nuclei(collect_nuclei(scrubbedNotebook, marker))\\\\n\\\\t\\\\t\\\\n\\\\t\\\\t#if marker==\\\\\\\"md\\\\\\\"\\\\n\\\\t\\\\t#\\\\tnotebook\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\tNb(collected_nuclei, filename)\\\\n\\\\t\\\\t#end\\\\nend\\\\n\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"6511de1e33f7a364\"), MIME type application/vnd.pluto.tree+object)), (12, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> strip --> Helper fucntion to replace a substring y in a string x with blank.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nstrip=(x::String,y) -> replace(x, y=>\\\\\\\"\\\\\\\")\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"9fe841be29a46787\"), MIME type application/vnd.pluto.tree+object)), (13, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nbegin\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> save_nb(io, notebook)--> Reads the supplied notebook and creates an io and writes stuffs like the module name and the content to the created io.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction save_nb(io, notebook)\\\\n println(io, _header)\\\\n println(io, _sub_header)\\\\n println(io, \\\\\\\"\\\\\\\")\\\\n println(io, \\\\\\\"module \\\\\\$(uppercasefirst(strip(strip(notebook.name, r\\\\\\\"[0-9_]\\\\\\\"), r\\\\\\\".jl\\\\\\\")))\\\\\\\")\\\\n\\\\tfor nucleus in notebook.nuclei\\\\n\\\\t\\\\t\\\\tprintln(io, nucleus.code*\\\\\\\"\\\\\\\\n\\\\\\\")\\\\n end\\\\n\\\\t#notebook\\\\n\\\\tprint(io, \\\\\\\"end\\\\\\\")\\\\t\\\\nend\\\\n\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> save_nb(notebook::Nb, path::String)--> Creates a file in the supplied path with the name in the NB type.\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction save_nb(notebook::Nb, path::String)\\\\n\\\\tfile_name=uppercasefirst(strip(notebook.name, r\\\\\\\"[0-9_]\\\\\\\"))\\\\n\\\\topen(joinpath(path, file_name), \\\\\\\"w\\\\\\\") do io\\\\n save_nb(io, notebook)\\\\n end\\\\nend\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"c9ed9a347daf1a0b\"), MIME type application/vnd.pluto.tree+object)), (14, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\nbegin\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> readfilenames()--> Reads files in the directory and subdirectories in the current path. Reads only the files with \\\\\\\".jl\\\\\\\" extension\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction readfilenames()\\\\n\\\\tfiles=[]\\\\n\\\\tfor file in readdir(normpath(joinpath(@__FILE__,\\\\\\\"..\\\\\\\",\\\\\\\"..\\\\\\\", \\\\\\\"nbs\\\\\\\")))\\\\n\\\\t\\\\t\\\\tif endswith(file, \\\\\\\".jl\\\\\\\")\\\\n\\\\t\\\\t\\\\t\\\\tpush!(files,file)\\\\n\\\\t\\\\t\\\\tend\\\\n\\\\t\\\\t\\\\t#if getfile_extension(file)== \\\\\\\".jl\\\\\\\"\\\\n\\\\t\\\\t\\\\t#\\\\tpush!(files,file)\\\\n\\\\t\\\\t\\\\t#end\\\\n\\\\tend\\\\n\\\\tfiles\\\\nend\\\\n\\\\nfunction readfilenames(dir::String)\\\\n\\\\tfiles=[]\\\\n\\\\tfor file in readdir(dir)\\\\n\\\\t\\\\t\\\\tif endswith(file, \\\\\\\".jl\\\\\\\")\\\\n\\\\t\\\\t\\\\t\\\\tpush!(files,file)\\\\n\\\\t\\\\t\\\\tend\\\\n\\\\t\\\\t\\\\t#if getfile_extension(file)== \\\\\\\".jl\\\\\\\"\\\\n\\\\t\\\\t\\\\t#\\\\tpush!(files,file)\\\\n\\\\t\\\\t\\\\t#end\\\\n\\\\tend\\\\n\\\\tfiles\\\\nend\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"fdf7a671e5c34491\"), MIME type application/vnd.pluto.tree+object)), (15, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> export_file(file::String, path::String, marker::String)--> Loads the file in the supplied path and reads the cells which are marked with \\\\\\\"#export\\\\\\\". Then saves the notebook in the given path\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction export_file(file::String, path::String, marker::String)\\\\n\\\\tnotebook=load_nb(file, \\\\\\\"#export\\\\\\\")\\\\n\\\\tsave_nb(notebook, path)\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"64e4a47cb39d3cf5\"), MIME type application/vnd.pluto.tree+object)), (16, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> export_content(files::AbstractVector, path::String, marker::String)--> maps the `export_file` function to each files\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction export_content(files::AbstractVector, path::String, marker::String)\\\\n\\\\tmap(file->export_file(file, path, marker), files)\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"d89912151b061910\"), MIME type application/vnd.pluto.tree+object)), (17, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> getfile_extension(filename)--> get the file extensions in the pwd\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction getfile_extension(filename)\\\\n return filename[findlast(isequal('.'),filename):end]\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"4a13057f7df9fc7f\"), MIME type application/vnd.pluto.tree+object)), (18, (Dict{Symbol, Any}(:prefix => \"Nucleus\", :elements => Any[(:code, (\"\\\"#export\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\n> notebook2script()--> Export all the code to the ../src path of the project\\\\n\\\\\\\"\\\\\\\"\\\\\\\"\\\\nfunction notebook2script()\\\\n\\\\texport_content(readfilenames(), \\\\\\\"../src\\\\\\\", \\\\\\\"#export\\\\\\\")\\\\nend\\\"\", MIME type text/plain))], :type => :struct, :prefix_short => \"Nucleus\", :objectid => \"92278d680e230cb3\"), MIME type application/vnd.pluto.tree+object))], :type => :Array, :prefix_short => \"\", :objectid => \"77793349d6ff63ef\"), MIME type application/vnd.pluto.tree+object)), (:name, (\"\\\"01_export.jl\\\"\", MIME type text/plain))], :struct, \"Nb\", \"7b12925ce165cbe5\"] testnb.nuclei[1].code ------ Output ------ \"#export\\nimport Pluto: Notebook, Cell, load_notebook_nobackup\" something to save files strip strip \u2013> Helper fucntion to replace a substring y in a string x with blank. Example \"module $(uppercasefirst(strip(strip(k, r\"[0-9_]\"), r\".jl\")))\" ------ Output ------ \"module Export\" To export the required code, the following scenarios must be considered. \ud83d\udc49 Check if the file is in the src directory. If it's there then overwrite it. \ud83d\udc49 If it's not there then create and then write. save_nb(io, notebook)\u2013> Reads the supplied notebook and creates an io and writes stuffs like the module name and the content to the created io. save_nb(notebook::Nb, path::String)\u2013> Creates a file in the supplied path with the name in the NB type. Example save_nb(testnb, \"../testpath\") ------ Output ------ We will read files in the current path which should be the /nbs folder in your project. This will host all your notebooks readfilenames readfilenames()\u2013> Reads files in the directory and subdirectories in the current path. Reads only the files with .jl\\ extension Example readfilenames() ------ Output ------ Any[\"Any\", Tuple{Int64, Any}[(1, (\"\\\"01_export.jl\\\"\", MIME type text/plain)), (2, (\"\\\"02_documenter.jl\\\"\", MIME type text/plain)), (3, (\"\\\"03_codeRunner.jl\\\"\", MIME type text/plain)), (4, (\"\\\"05_makedocs.jl\\\"\", MIME type text/plain)), (5, (\"\\\"06_index.jl\\\"\", MIME type text/plain))], :Array, \"\", \"dff1b136b2da593b\"] export_file export_file(file::String, path::String, marker::String)\u2013> Loads the file in the supplied path and reads the cells which are marked with #export. Then saves the notebook in the given path export_content export*content(files::AbstractVector, path::String, marker::String)\u2013> maps the export*file function to each files getfile_extension getfile_extension(filename)\u2013> get the file extensions in the pwd Example getfile_extension(\"test.jl\") ------ Output ------ \".jl\" notebook2script notebook2script()\u2013> Export all the code to the ../src path of the project notebook2script can be called from anotebook which you intend to export. Usually in the last cell of that notebook notebook2script() ------ Output ------ Any[\"Nothing\", Tuple{Int64, Any}[(1, (\"nothing\", MIME type text/plain)), (2, (\"nothing\", MIME type text/plain)), (3, (\"nothing\", MIME type text/plain)), (4, (\"nothing\", MIME type text/plain)), (5, (\"nothing\", MIME type text/plain))], :Array, \"\", \"eace4e8e41d845ae\"]","title":"Export"},{"location":"Index/","text":"Index Nbdev This project is an attempt to port fastai Nbdev to Julia. Nbdev(both the oriignal version and the Julia version) are based on the idea of using Notebooks for literate programming. On a very high level the base idea is this \ud83d\udc47 While both projects try to achieve the same base goal i.e. generating source code and documentation from Notebooks, the Julia version aims to start from Pluto notebook while the python version starts from a Jupyter notebook. On the documentation side, I am using Mkdocs as the document generator while the original version uses Jekyll as the static site generator of choice.","title":"Home"},{"location":"Makedocs/","text":"Makedocs This module takes care of the creation of the support system document generation such as directory creation, index.yml and mkdocs.yml creation. Additionally it calls mkdocs commands to build the site makepath create the given path if not present makepath(\"../docs/docs\") ------ Output ------ mkdocs_yml mkdocs_yml()\u2013> Creates a mkdocs.yml file at the document root and fills it with initial content. mkdocs_yml(\"../docs\") ------ Output ------ newsitegen newsitegen()\u2013> Create required directory structure for hosting documents and the initial files(index.md and mkdocs.yml) if not already there.","title":"MakeDocs"}]}