### A Nbdev script file ###
### Autogenerated file. Don't modify. ###

module Export
#export
import Pluto: Notebook, Cell, load_notebook_nobackup

#export
function processMdChunk(mdChunk::String)
	chopMdMarker(mdChunk)
end

#export
begin
Base.@kwdef mutable struct Nucleus
	code::String=""
	end
	
Nucleus(code) = Nucleus(code = code)
end

#export
begin
mutable struct Nb
	nuclei::Array{Nucleus,1}
	name::AbstractString
end

nuclei(nuclei::Array) = nuclei
name(name::AbstractString) = name
end

#export
begin
const _header = "### A Nbdev script file ###"
const _sub_header = "### Autogenerated file. Don't modify. ###"
end

#export
#This had to be done becasue having the cell iddelimeter as a constant gives an error during parsing the notebook
cell_id_delimiter=string("#"," ╔═╡ ")

#export
const _cell_suffix = "\n\n"

#export
mutable struct ScrubbedNotebook
	cells::Array{String, 1}
end

#export
function collect_nuclei(notebook::ScrubbedNotebook, marker)
	notebook_cells=notebook.cells
	nuclei=[]
		
    for i in 1:length(notebook_cells)
    	raw_code=notebook_cells[i]
    	nucleus=Nucleus(raw_code)
    	
    	if startswith(raw_code, marker)
            push!(nuclei,nucleus)
        end
    	
    end
	 nuclei
end

#export
begin
"""
	This is a modification of the Pluto.load_notebook methods
"""
function load_scrubbed_nb(io, path)::ScrubbedNotebook
    collected_cells = []
		
	# ignore first bits of file
    readuntil(io,cell_id_delimiter)

    last_read = ""
    while !eof(io)
        cell_id_str = String(readline(io))
        if cell_id_str == "Cell order:"
            break
        else
            code_raw = String(readuntil(io, cell_id_delimiter))
            # change Windows line endings to Linux
            code_normalised = replace(code_raw, "\r\n" => "\n")
            # remove the cell appendix
            code = code_normalised[1:prevind(code_normalised, end, length(_cell_suffix))]

            read_cell = code
            push!(collected_cells, read_cell)
        end
    end
		
	ScrubbedNotebook(collected_cells)
end
	
function load_scrubbed_nb(path::String)::ScrubbedNotebook
    local loaded
    open(path, "r") do io
        loaded = load_scrubbed_nb(io, path)
    end
    loaded
end
end

#export
begin
	
load_nb(filename::String, marker::String) = _load_nb(filename, marker)
	
function _load_nb(filename::String, marker::String)
		#notebook=load_notebook_nobackup(filename)
		scrubbedNotebook=load_scrubbed_nb(filename)
		collected_nuclei=nuclei(collect_nuclei(scrubbedNotebook, marker))
		
		#if marker=="md"
		#	notebook
		#else
		Nb(collected_nuclei, filename)
		#end
end

end

#export
strip=(x::String,y) -> replace(x, y=>"")

#export
begin
	
function save_nb(io, notebook)
    println(io, _header)
    println(io, _sub_header)
    println(io, "")
    println(io, "module $(uppercasefirst(strip(strip(notebook.name, r"[0-9_]"), r".jl")))")
	for nucleus in notebook.nuclei
			println(io, nucleus.code*"\n")
    end
	#notebook
	print(io, "end")	
end

function save_nb(notebook::Nb, path::String)
	file_name=uppercasefirst(strip(notebook.name, r"[0-9_]"))
	open(joinpath(path, file_name), "w") do io
        save_nb(io, notebook)
    end
end
end

#export
begin
function readfilenames()
	files=[]
	for file in readdir()
			if endswith(file, ".jl")
				push!(files,file)
			end
			#if getfile_extension(file)== ".jl"
			#	push!(files,file)
			#end
	end
	files
end

function readfilenames(dir::String)
	files=cd(readdir, dir)
	files
end
end

#export
function export_file(file::String, path::String, marker::String)
	notebook=load_nb(file, "#export")
	save_nb(notebook, path)
end

#export
function export_content(files::AbstractVector, path::String, marker::String)
	map(file->export_file(file, path, marker), files)
end

#export
function getfile_extension(filename)
    return filename[findlast(isequal('.'),filename):end]
end

#export
function notebook2script()
	export_content(readfilenames(), "../src", "#export")
end

end